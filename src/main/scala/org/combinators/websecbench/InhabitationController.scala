/*
 * Websecbench is a suite of web security benchmarks generated by (CL)S.
 * Copyright (C) 2021  Jan Bessai and Malte Mues
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

package org.combinators.websecbench
import java.nio.file.{Files, Path, Paths}
import cats.effect.{ExitCode, IO, IOApp}
import cats.implicits._
import com.github.javaparser.ast.expr.Expression
import org.combinators.templating.persistable.JavaPersistable._
import org.combinators.cls.types.Type
import org.combinators.jgitserv.{BranchTransaction, ResourcePersistable}
import org.combinators.templating.persistable.BundledResource
import org.combinators.websecbench.SemanticTypes.JavaVoid

final case class BenchmarkSelector(
    tags: Set[ComponentTag],
    targetType: Type,
    maximalNumberOfResults: Int
)

class BenchmarkController(
    selectedBenchmarks: Set[BenchmarkSelector],
    benchmarkName: String,
    targetDirectory: Path,
    shuffleSolutions: Boolean = true
) extends IOApp {

  lazy val buildDotSbt: BundledResource =
    BundledResource("/build.sbt", Paths.get("build.sbt"), getClass)
  lazy val owaspUtils: BundledResource =
    BundledResource(
      "/org/owasp/benchmark/helpers/Utils.java",
      Paths.get(
        "src",
        "main",
        "java",
        "org",
        "owasp",
        "benchmark",
        "helpers",
        "Utils.java"
      ),
      getClass
    )
  lazy val storeResource = ResourcePersistable.apply

  lazy val emptyBenchmark: IO[Unit] = IO {
    Files.createDirectories(targetDirectory)
    storeResource.persistOverwriting(targetDirectory, buildDotSbt)
    storeResource.persistOverwriting(targetDirectory, owaspUtils)
  }

  lazy val numberFormat: String = {
    val maxBenchmarks = selectedBenchmarks.map(_.maximalNumberOfResults).sum
    s"%0${maxBenchmarks.toString.length}d"
  }

  def transactionFor(
      benchmarkSelector: BenchmarkSelector
  ): Seq[Int => IO[Unit]] = {
    val Gamma = Repository.repository(benchmarkSelector.tags)
    val results =
      Gamma.inhabit[CodeGenerator[Expression]](benchmarkSelector.targetType)
    val toStore = results.size
      .map(s => Math.min(benchmarkSelector.maximalNumberOfResults, s.toInt))
      .getOrElse(benchmarkSelector.maximalNumberOfResults)

    (0 until toStore).foldLeft(Seq.empty[Int => IO[Unit]]) {
      case (transactions, resultNumber) =>
        val nextTransaction = (nextNumber: Int) => {
          val currentName =
            s"%s_$numberFormat".format(benchmarkName, nextNumber)
          val storeCompilationUnit =
            CodeGenerator.compilationUnitPersistable[Expression](currentName)
          val storeVulnerabilityReport = CodeGenerator
            .vulnerabilityReportPersistable[Expression](currentName)
          val result = results.interpretedTerms.index(BigInt(resultNumber))
          IO[Unit] {
            storeCompilationUnit.persistOverwriting(targetDirectory, result)
            storeVulnerabilityReport.persistOverwriting(targetDirectory, result)
          }
        }
        nextTransaction +: transactions
    }
  }

  def computeTransactions: Seq[IO[Unit]] = {
    val transactions =
      selectedBenchmarks.toSeq.flatMap(transactionFor)
    val suffledTransactions =
      if (shuffleSolutions) scala.util.Random.shuffle(transactions)
      else transactions
    emptyBenchmark +:
      suffledTransactions.zipWithIndex
        .map { case (transaction, number) => transaction(number) }
  }

  def run(args: List[String]): IO[ExitCode] = {
    for {
      _ <- IO { println("Computing solutions") }
      transactions = computeTransactions
      _ <- transactions.toList.sequence
    } yield ExitCode.Success
  }
}

object Benchmark42
    extends BenchmarkController(
      Set(
        BenchmarkSelector(
          tags = Set(
            ComponentTag.FileIO,
            ComponentTag.Process,
            ComponentTag.ReadFromRequest,
            ComponentTag.DatabaseIO
          ),
          targetType = JavaVoid,
          maximalNumberOfResults = 100
        )
      ),
      benchmarkName = "benchmark42",
      targetDirectory = Paths.get("target", "benchmarks"),
      shuffleSolutions = false
    )
